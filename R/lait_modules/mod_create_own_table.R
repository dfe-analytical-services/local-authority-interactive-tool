# nolint start: object_name
#
# Staging table ================================================================
# Staging BDS ------------------------------------------------------------------
# Filter the BDS for current user input selections
# (used to create the staging table)
#
#' Staging BDS Server
#'
#' This function filters the BDS (Business Data Service) metrics based on
#' user input selections to create a staging table. It filters for selected
#' topic-indicator pairs, geographic groupings, and a specified year range.
#'
#' @param id A unique identifier for the Shiny module.
#' @param create_inputs A list of reactive inputs generated by the main
#'                      input module, including selected topic-indicator pairs.
#' @param geog_groups A reactive expression providing the selected geographic
#'                     groups based on user input.
#' @param year_input A list containing reactive expressions for selected
#'                   year range and available years choices.
#' @param bds_metrics A data frame containing the business data service metrics
#'                    used for filtering based on user selections.
#' @return A reactive data frame that contains the filtered BDS metrics
#'         suitable for display in the staging table.
#'
StagingBDSServer <- function(id,
                             create_inputs,
                             geog_groups,
                             year_input,
                             bds_metrics) {
  moduleServer(id, function(input, output, session) {
    # Forcing module to react to change in year input (not best practice)
    observeEvent(year_input$range(), {
      year_input$range()
    })

    # Filter BDS for topic-indicator pairs in the selected_values reactive
    topic_indicator_bds <- reactive({
      req(length(create_inputs$indicator()) > 0)
      bds_metrics |>
        dplyr::filter(Measure %in% create_inputs$indicator())
    })

    # Now filter BDS for geographies and year range
    # Split from above so if indicator doesn't change then don't recompute
    staging_bds <- reactive({
      req(geog_groups(), topic_indicator_bds())
      # Filter by full geography inputs
      filtered_bds <- topic_indicator_bds() |>
        dplyr::filter(
          `LA and Regions` %in% geog_groups()
        )

      # Cleaning Years
      # Check if all years have consistent suffix
      consistent_str_years <- check_year_suffix_consistency(filtered_bds)

      # If not consistent suffix use the cleaned year cols (numeric years)
      if (!consistent_str_years) {
        filtered_bds <- filtered_bds |>
          dplyr::mutate(
            Years = Years_num
          )
      }

      # Apply the year range filter
      # If only one year selected then show just that year
      if (length(year_input$range()) == 1) {
        filtered_bds <- filtered_bds |>
          dplyr::filter(
            Years == year_input$range()[1]
          )
      } else if (length(year_input$range()) == 2) {
        filtered_bds <- filtered_bds |>
          dplyr::filter(
            Years >= year_input$range()[1],
            Years <= year_input$range()[2]
          )
      }

      # Return the user selection filtered data for staging table
      filtered_bds
    })


    # Return staging BDS
    staging_bds
  })
}


# Staging data -----------------------------------------------------------------
#
#' Staging Data Server
#'
#' This function builds a staging table for displaying filtered BDS metrics
#' in a Shiny application. It incorporates statistical neighbour associations
#' if selected and formats the data into a wide format for easier analysis.
#'
#' @param id A unique identifier for the Shiny module.
#' @param create_inputs A list of reactive inputs generated by the main
#'                      input module, including selected topic-indicator pairs.
#' @param staging_bds A reactive expression providing the filtered BDS metrics
#'                     based on user selections.
#' @param region_names_bds A vector of names representing regions in the BDS.
#' @param la_names_bds A vector of names representing local authorities in the BDS.
#' @param stat_n_la A data frame containing statistical neighbour data for LAs.
#' @return A reactive data frame that contains the formatted staging table
#'         ready for display in the Shiny app.
#'
StagingDataServer <- function(
    id, create_inputs, staging_bds, region_names_bds, la_names_bds, stat_n_la) {
  moduleServer(id, function(input, output, session) {
    # Make statistical neighbour association table available
    stat_n_association <- StatN_AssociationServer(
      "stat_n_association",
      create_inputs,
      la_names_bds,
      stat_n_la
    )

    # Build the staging table
    staging_table <- reactive({
      # Selected relevant cols
      # Coerce to wide format
      # (any new values created set to NaN so can be picked up as user created NAs)
      # Set regions and England as themselves for Region
      wide_table <- staging_bds() |>
        dplyr::select(
          `LA Number`, `LA and Regions`, Region, Topic,
          Measure, Years, Years_num, values_num, Values
        ) |>
        tidyr::pivot_wider(
          id_cols = c("LA Number", "LA and Regions", "Region", "Topic", "Measure"),
          names_from = Years,
          values_from = values_num,
          values_fill = NaN
        ) |>
        dplyr::mutate(Region = dplyr::case_when(
          `LA and Regions` %in% c("England", region_names_bds) ~ `LA and Regions`,
          TRUE ~ Region
        ))

      # Order columns (and sort year cols order)
      wide_table_ordered <- wide_table |>
        dplyr::select(
          `LA Number`, `LA and Regions`, Region,
          Topic, Measure,
          dplyr::all_of(sort_year_columns(wide_table))
        )

      # If SNs included, add SN LA association column
      # Multi-join as want to include an association for every row (even duplicates)
      if (isTRUE(create_inputs$la_group() == "la_stat_ns")) {
        wide_table_ordered <- wide_table_ordered |>
          dplyr::left_join(
            stat_n_association(),
            by = "LA and Regions",
            relationship = "many-to-many"
          ) |>
          dplyr::relocate(sn_parent, .after = "Measure") |>
          dplyr::rename("Statistical Neighbour Group" = "sn_parent")
      }

      # Staging table formatted and ready for output
      wide_table_ordered
    })

    # Return staging table
    staging_table
  })
}


# Staging table UI -------------------------------------------------------------
# Simple reactable table inside a well div
#
#' Staging Table UI
#'
#' This function creates the user interface for the staging table, which
#' displays the current selections in a well-styled format. The UI includes
#' a header and a reactable output for rendering the staging data.
#'
#' @param id A unique identifier for the Shiny module.
#' @return A div containing the UI elements for the staging table, including
#'         a header and a reactable output.
#'
StagingTableUI <- function(id) {
  ns <- NS(id)

  div(
    class = "well",
    style = "overflow-y: visible;",
    bslib::layout_column_wrap(
      h2(
        "Staging Table",
        create_tooltip_icon("Showing data from current selections")
      ),
      # Include empty divs so matches inputs above and add selections aligns
      div(),
      div(),
      # Add selections button
      Create_MainInputsUI("create_inputs")["Add selection"]
    ),
    bslib::card(
      with_gov_spinner(
        reactable::reactableOutput(ns("staging_table")),
        size = 0.5
      )
    )
  )
}


# Staging table Server ---------------------------------------------------------
# Output a formatted reactable table of the staging data
# Few error message table outputs for incorrect/ missing selections
#
#' Staging Table Server
#'
#' This function generates the server-side logic for the staging table, which
#' renders a reactable table of the current selections. It handles error
#' messages for incorrect or missing selections and formats the staging data
#' for better readability. It filters the BDS data based on user inputs and
#' prepares it for display.
#'
#' @param id A unique identifier for the Shiny module.
#' @param create_inputs A list of reactive inputs generated by the main input
#'                      module, including selected indicators and geography.
#' @param region_names_bds A vector of names representing regions in the BDS.
#' @param la_names_bds A vector of names representing local authorities in the BDS.
#' @param stat_n_la A data frame containing statistical neighbour data for LAs.
#' @param geog_groups A reactive expression that provides the selected geography
#'                     groups based on user input.
#' @param year_input A reactive expression providing the selected year range.
#' @param bds_metrics A data frame containing the BDS metrics used for filtering.
#' @return A reactable output for the staging table, displaying filtered BDS data
#'         or error messages based on user selections.
StagingTableServer <- function(id,
                               create_inputs,
                               region_names_bds,
                               la_names_bds,
                               stat_n_la,
                               geog_groups,
                               year_input,
                               bds_metrics) {
  moduleServer(id, function(input, output, session) {
    # Staging table reactable ouput
    output$staging_table <- reactable::renderReactable({
      # Display messages if there are incorrect selections
      if (length(create_inputs$indicator()) == 0 && is.null(geog_groups())) {
        return(dfe_reactable(
          data.frame(
            `Message from tool` = "Please add selections (above).",
            check.names = FALSE
          )
        ))
      } else if (length(create_inputs$indicator()) == 0) {
        return(dfe_reactable(
          data.frame(
            `Message from tool` = "Please add an indicator selection (above).",
            check.names = FALSE
          )
        ))
      } else if (is.null(geog_groups())) {
        return(dfe_reactable(
          data.frame(
            `Message from tool` = "Please add a geography selection (above).",
            check.names = FALSE
          )
        ))
      }

      # Filtering BDS for staging data
      staging_bds <- StagingBDSServer(
        "staging_bds",
        create_inputs,
        geog_groups,
        year_input,
        bds_metrics
      )

      # Build staging data
      staging_data <- StagingDataServer(
        "staging_data",
        create_inputs,
        staging_bds,
        region_names_bds,
        la_names_bds,
        stat_n_la
      )

      # Output table - formatting numbers, long text and page settings
      dfe_reactable(
        staging_data(),
        columns = utils::modifyList(
          format_num_reactable_cols(
            staging_data(),
            get_indicator_dps(staging_bds()),
            num_exclude = c("LA Number", "Topic", "Measure")
          ),
          list(
            set_custom_default_col_widths(
              Measure = set_min_col_width(90)
            ),
            # Truncates long cell values and displays hover with full value
            Measure = reactable::colDef(
              html = TRUE,
              cell = function(value, index, name) {
                truncate_cell_with_hover(text = value, tooltip = value)
              }
            )
          )
        ),
        defaultPageSize = 3,
        showPageSizeOptions = TRUE,
        pageSizeOptions = c(3, 5, 10, 25),
        compact = TRUE
      )
    })
  })
}


# Query table ==================================================================
# Query data -------------------------------------------------------------------
#
#' Query Data Server
#'
#' This function manages the server-side logic for storing and displaying
#' queries based on user selections. It allows users to add queries to a
#' saved list and formats the data for display. The function maintains
#' a reactive data structure that includes the selected topics, indicators,
#' geography, and year range.
#'
#' @param id A unique identifier for the Shiny module.
#' @param create_inputs A list of reactive inputs generated by the main input
#'                      module, including selected indicators and geography.
#' @param geog_groups A reactive expression that provides the selected geography
#'                     groups based on user input.
#' @param year_input A reactive expression providing the selected year range.
#' @param staging_data A reactive expression that contains the staging data
#'                     filtered based on user selections.
#' @return A reactive value list containing the current queries and output data
#'         for display, including options for removing queries.
#'
QueryDataServer <- function(id,
                            create_inputs,
                            geog_groups,
                            year_input,
                            staging_data) {
  moduleServer(id, function(input, output, session) {
    # Reactive value "query" used to store query data
    # Uses lists to store multiple inputs (Geographies & Indicators)
    query <- reactiveValues(
      data = data.frame(
        Topic = I(list()),
        Indicator = I(list()),
        `LA and Regions` = I(list()),
        `Year range` = I(list()),
        `Click to remove query` = character(),
        `.query_id` = numeric(),
        check.names = FALSE
      ),
      output = data.frame(
        `LA Number` = character(),
        `LA and Regions` = character(),
        Region = character(),
        Topic = character(),
        Measure = character(),
        check.names = FALSE
      )
    )

    # When "Add table" button clicked - add query to saved queries
    observeEvent(create_inputs$add_query(),
      {
        # Check if anything selected
        req(length(geog_groups()) > 0 && length(create_inputs$indicator()) > 0)

        # Create a unique identifier for the new query (current no of queries + 1)
        new_q_id <- max(c(0, query$data$.query_id), na.rm = TRUE) + 1

        # Creating year range info
        # Get the range of available years
        available_years <- range(year_input$choices())

        # Define the year range info logic
        # None selected - all years - "All years (x to y)"
        # Range selected - "x to y"
        # One year selected - "x"
        year_range_display <- dplyr::case_when(
          length(year_input$range()) == 0 ~ paste0("All years (", available_years[1], " to ", available_years[2], ")"),
          length(year_input$range()) == 2 ~ paste(year_input$range()[1], "to", year_input$range()[2]),
          length(year_input$range()) == 1 ~ paste0("", year_input$range()[1])
        )

        # Evaluate user inputs for get_geog_selection()
        evaluated_inputs <- list(
          geog = create_inputs$geog(),
          la_group = create_inputs$la_group(),
          inc_regions = create_inputs$inc_regions(),
          inc_england = create_inputs$inc_england()
        )

        # Get selected Indicator Topics
        selected_topics <- staging_data() |>
          pull_uniques("Topic")

        # Create query information
        # Split multiple input choices with commas and line breaks
        # (indicator x, indicator y)
        # Assign the new query ID, selected topic-indicator pairs,
        # create the geog selections (special formatting  for groupings),
        # year range (with logic from above) and the remove col
        new_query <- data.frame(
          .query_id = new_q_id,
          Topic = paste(selected_topics, collapse = ",<br>"),
          Indicator = paste(create_inputs$indicator(), collapse = ",<br>"),
          `LA and Regions` = paste(
            get_geog_selection(evaluated_inputs, la_names_bds, region_names_bds, stat_n_geog),
            collapse = ",<br>"
          ),
          `Year range` = year_range_display,
          `Click to remove query` = "Remove",
          check.names = FALSE
        )

        # Append new query to the existing queries
        query$data <- query$data |>
          rbind(new_query)

        # Appending the data of the new query to the output table
        # Adding new query ID to staging data
        # (so remove button also removes relevant data from output table)
        query_output <- query$output
        staging_to_append <- staging_data()
        staging_to_append$.query_id <- new_q_id
        consistent_staging_final_yrs <- data.frame(
          Years = c(
            colnames(query_output)[grepl("^\\d{4}", colnames(query_output))],
            colnames(staging_to_append)[grepl("^\\d{4}", colnames(staging_to_append))]
          )
        ) |> check_year_suffix_consistency()

        # If not consistent suffixes then clean both dfs year cols
        if (!consistent_staging_final_yrs && nrow(query_output) > 0) {
          query_output <- rename_columns_with_year(query_output)
          staging_to_append <- rename_columns_with_year(staging_to_append)
        }

        # Get all years across both dfs
        all_year_columns <- union(
          grep("^\\d{4}", names(query_output), value = TRUE),
          grep("^\\d{4}", names(staging_to_append), value = TRUE)
        )

        # Add the new (missing) years onto the existing dfs with values as NaN
        # This is so that they can be coded as "-" in the table
        # Saved queries
        if (nrow(query_output) > 0) {
          for (col in setdiff(all_year_columns, names(query_output))) {
            query_output[[col]] <- NaN
          }
        }

        # New query
        if (nrow(staging_to_append) > 0) {
          for (col in setdiff(all_year_columns, names(staging_to_append))) {
            staging_to_append[[col]] <- NaN
          }
        }

        # Combine query tables for final table output
        query$output <- rbind(query_output, staging_to_append)
      },
      ignoreInit = TRUE
    )

    query
  })
}


# Query Table UI ---------------------------------------------------------------
#
#' Query Table UI
#'
#' This function creates the user interface for displaying a summary of
#' saved queries in a well-styled format. It includes a reactable table
#' output to present the user's selections.
#'
#' @param id A unique identifier for the Shiny module.
#' @return A UI element that displays a summary of selections in a
#'         reactable table format.
#'
QueryTableUI <- function(id) {
  ns <- NS(id)

  div(
    class = "well",
    style = "overflow-y: visible;",
    h2("Summary of Selections"),
    bslib::card(
      with_gov_spinner(
        reactable::reactableOutput(ns("query_table")),
        size = 0.5
      )
    )
  )
}

# Query Table Server -----------------------------------------------------------
# Renders the query table and manages removal actions
#
#' Query Table Server
#'
#' This function handles the server-side logic for rendering the query
#' table and managing the removal of saved queries. It displays the
#' current queries and allows users to remove specific entries.
#'
#' @param id A unique identifier for the Shiny module.
#' @param query A reactive list containing the current query data, including
#'               saved queries and output for display.
#' @return A reactive value list that updates when queries are added or
#'         removed, reflecting the current state of the query data.
#'
QueryTableServer <- function(id, query) {
  moduleServer(id, function(input, output, session) {
    # Display message if there are no saved selections
    output$query_table <- reactable::renderReactable({
      req(nrow(query$data))
      if (nrow(query$data) == 0) {
        return(dfe_reactable(
          data.frame(`Message from tool` = "No saved selections.", check.names = FALSE)
        ))
      }

      # Output table - Allow html (for <br>),
      # add the JS from reactable.extras::button_extra() for remove button
      # Show only unique topics and remove the query ID col
      dfe_reactable(
        query$data,
        columns = list(
          Indicator = html_col_def(),
          `LA and Regions` = html_col_def(),
          `Click to remove query` = reactable::colDef(
            cell = reactable::JS(
              "function(cellInfo) {
                const buttonId = 'query_table-remove-' + cellInfo.row['.query_id'];
                console.log('Generated button ID:', buttonId);  // Confirm buttonId in console
                return React.createElement(ButtonExtras, {
                  id: buttonId,
                  label: 'Remove',
                  uuid: cellInfo.row['.query_id'],
                  column: cellInfo.column.id,
                  class: 'govuk-button--warning',
                  className: 'govuk-button--warning'
                }, cellInfo.index);
              }"
            )
          ),
          Topic = html_col_def(),
          .query_id = reactable::colDef(show = FALSE)
        ),
        defaultPageSize = 5,
        showPageSizeOptions = TRUE,
        pageSizeOptions = c(5, 10, 25),
        compact = TRUE
      )
    })

    # Remove query button logic
    observe({
      req(nrow(query$data))

      # Create button observers for each row using the query ID
      lapply(query$data$.query_id, function(q_id) {
        # Create matching query ID for each remove button
        remove_button_id <- paste0("remove-", q_id)

        # Observe the button click
        observeEvent(input[[remove_button_id]],
          {
            # Remove the corresponding row (query) from query$data using the query ID
            query$data <- query$data[query$data$.query_id != q_id, , drop = FALSE]

            # Also remove the corresponding rows from query$output
            query$output <- query$output[query$output$.query_id != q_id, , drop = FALSE]

            # If no rows (queries) left then also remove the years cols
            # This is so that if a user wants a range of years next
            # the legacy years aren't still there
            if (nrow(query$output) == 0) {
              query$output <- query$output |>
                dplyr::select(
                  `LA Number`,
                  `LA and Regions`,
                  Region,
                  Topic,
                  Measure,
                  .query_id
                )
            }
          },
          ignoreInit = TRUE
        )
      })
    })

    # Output updated query (which is up-to-date with any removed rows)
    query
  })
}


# Create Own Table =============================================================
# Create Own Data --------------------------------------------------------------
#
#' Create Own Data Server
#'
#' This function processes saved queries and generates a cleaned final
#' table output for display. It checks for year suffix consistency and
#' adjusts the column names accordingly. If there are no saved queries,
#' it returns a message indicating this.
#'
#' @param id A unique identifier for the Shiny module.
#' @param query A reactive list containing the current query data, including
#'               saved queries and output for display.
#' @param bds_metrics A data frame containing metrics related to the BDS,
#'                    which is used to verify year suffix consistency.
#' @return A reactive data frame containing the cleaned final output table
#'         with correctly formatted year columns and relevant information.
#'
CreateOwnDataServer <- function(id, query, bds_metrics) {
  moduleServer(id, function(input, output, session) {
    # Building data for the output of all saved queries
    clean_final_table <- reactive({
      req(query$data)

      # Check if there are any saved queries
      if (nrow(query$data) == 0) {
        return(
          data.frame(
            `Message from tool` = "No saved selections.",
            check.names = FALSE
          )
        )
      }

      # Remove columns that contain only NaN values
      # (aka user removed query that was including these years so no need to display them now)
      query_output_clean <- query$output[, !sapply(query$output, function(x) all(is.nan(x)))]

      # Logic to reset the year cols to have year suffixes if they match
      # (As they may have been cleaned from the code logic at end of the new query chunk)
      # Determine if output indicators share year suffix consistency
      output_indicators <- query_output_clean |> pull_uniques("Measure")
      share_year_suffix <- bds_metrics |>
        dplyr::filter(Measure %in% output_indicators) |>
        check_year_suffix_consistency()

      # Reapply year suffixes to columns if needed
      if (share_year_suffix) {
        years_dict <- bds_metrics |>
          dplyr::filter(Measure %in% output_indicators) |>
          dplyr::distinct(Years, Years_num)

        # Replace numeric year columns with the corresponding suffix
        new_col_names <- colnames(query_output_clean) |>
          vapply(function(col) {
            if (col %in% years_dict$Years_num) {
              return(years_dict$Years[match(col, years_dict$Years_num)])
            } else {
              return(col)
            }
          }, character(1))

        colnames(query_output_clean) <- new_col_names
      }

      # Final query output table with ordered columns (SN parent if selected)
      # and sorted year columns
      query_output_clean |>
        dplyr::select(
          `LA Number`, `LA and Regions`,
          Region, Topic, Measure,
          tidyselect::any_of("Statistical Neighbour Group"),
          dplyr::all_of(sort_year_columns(query_output_clean))
        )
    })

    # Return data ready to render as output of Create Own Table
    clean_final_table
  })
}


# Create Own BDS ---------------------------------------------------------------
#
#' Create Own BDS Server
#'
#' This function filters the BDS metrics based on the topic-indicator pairs
#' present in the final output table. It returns a reactive data frame
#' containing only the relevant entries from the BDS that match the specified
#' selections.
#'
#' @param id A unique identifier for the Shiny module.
#' @param create_own_table A reactive expression that returns the final output
#'                          table containing selected topic-indicator pairs.
#' @param bds_metrics A data frame containing the full BDS metrics to be
#'                    filtered based on the selections.
#' @return A reactive data frame containing the filtered BDS metrics based
#'         on the selected topic-indicator pairs from the final output table.
#'
CreateOwnBDSServer <- function(id, create_own_table, bds_metrics) {
  moduleServer(id, function(input, output, session) {
    # Filtering BDS for all topic-indicator pairs in the final output table
    # (The filtered_bds only has the staging topic-indicator pairs)
    final_filtered_bds <- reactive({
      output_table_filters <- create_own_table() |>
        dplyr::distinct(`LA and Regions`, Topic, Measure)

      bds_metrics |>
        dplyr::semi_join(
          output_table_filters,
          by = c("LA and Regions", "Topic", "Measure")
        )
    })

    final_filtered_bds
  })
}


# Create Own Table UI ----------------------------------------------------------
#
#' Create Own Table UI
#'
#' This function generates the user interface for displaying the output table
#' that shows all saved selections, along with a download section for exporting
#' the table in various file formats.
#'
#' @param id A unique identifier for the Shiny module, used for namespacing.
#' @return A UI component consisting of a well containing the output table and
#'         download options.
#'
CreateOwnTableUI <- function(id) {
  ns <- NS(id)

  div(
    class = "well",
    style = "overflow-y: visible;",
    h2(
      "Output Table",
      create_tooltip_icon(
        '<ul style="text-align: left; margin-left: 0; padding-left: 20px;">
         <li>Showing data from all the saved selections</li>
         <li>Populate by clicking the "Add selections" button</li>
       </ul>
      '
      )
    ),
    bslib::navset_card_tab(
      # Create Own Table -------------------------------------------------------
      bslib::nav_panel(
        title = "Output Table",
        with_gov_spinner(
          reactable::reactableOutput(ns("output_table")),
          size = 0.75
        )
      ),
      # Create Own Download ----------------------------------------------------
      bslib::nav_panel(
        title = "Download",
        shiny::uiOutput(ns("download_file_txt")),
        Download_DataUI(ns("table_download"), "Output Table")
      )
    )
  )
}

# Create Own Table Server ------------------------------------------------------
#
#' Create Own Table Server
#'
#' This function manages the server logic for displaying the output table
#' based on all saved selections. It handles the formatting of the data
#' and the functionality for downloading the table in different formats.
#'
#' @param id A unique identifier for the Shiny module.
#' @param query A reactive object containing saved queries and their data.
#' @param bds_metrics A data frame containing the full BDS metrics used
#'                    for filtering and formatting the output table.
#' @return None. This function updates the output table and manages
#'         download functionality within the Shiny app.
#'
CreateOwnTableServer <- function(id, query, bds_metrics) {
  moduleServer(id, function(input, output, session) {
    # Load data for Create Own Table
    create_own_data <- CreateOwnDataServer(
      "create_own_table",
      query,
      bds_metrics
    )

    # Load BDS made from Create Own data
    create_own_bds <- CreateOwnBDSServer(
      "create_own_bds",
      create_own_data,
      bds_metrics
    )

    # Final output table (based on saved queries) ------------------------------
    output$output_table <- reactable::renderReactable({
      # Display the final query table data
      # Format numeric cols (using dps based of output table indicators),
      # Truncate measure with hover and page settings
      dfe_reactable(
        create_own_data(),
        columns = utils::modifyList(
          format_num_reactable_cols(
            create_own_data(),
            get_indicator_dps(create_own_bds()),
            num_exclude = c("LA Number", "Topic", "Measure")
          ),
          list(
            set_custom_default_col_widths(),
            Measure = reactable::colDef(
              html = TRUE,
              cell = function(value, index, name) {
                truncate_cell_with_hover(text = value, tooltip = value)
              }
            )
          )
        ),
        defaultPageSize = 5,
        showPageSizeOptions = TRUE,
        pageSizeOptions = c(5, 10, 25),
        compact = TRUE
      )
    })

    # Download the output table ------------------------------------------------
    # File download text - calculates file size
    ns <- NS(id)
    output$download_file_txt <- shiny::renderUI({
      file_type_input_btn(ns("file_type"), replace_nan_with_empty(create_own_data()))
    })

    # Download dataset
    Download_DataServer(
      "table_download",
      reactive(input$file_type),
      reactive(replace_nan_with_empty(create_own_data())),
      reactive("LAIT-create-your-own-table")
    )
  })
}

# nolint end
